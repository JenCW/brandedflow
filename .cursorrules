# ============================================
# GLOBAL FOUNDATIONAL RULES - DOE ARCHITECTURE
# This file applies to ALL projects, workspaces, windows, chats, and models
# MANDATORY ENFORCEMENT - NO EXCEPTIONS
# ============================================

# ============================================
# I. FOUNDATIONAL STRATEGY: BLUEPRINT-FIRST APPROACH
# ============================================

## THE BLUEPRINT-FIRST DIRECTIVE (MANDATORY)

A detailed coding plan (Blueprint) is MANDATORY before any code generation. This prevents chaotic, flawed output from unguided "vibe coding".

### PHASE 1: BLUEPRINT (MANDATORY BEFORE ANY CODE)
**STOP & THINK FIRST. You MUST:**

1. **Research Phase:**
   - Read the ENTIRE codebase relevant to the task
   - Review all specifications and documentation
   - Check for existing `project_config.md` or `project_milestones.md` for stable, long-term context
   - Review `workflow_state.md` or `Documentation.md` for current phase, task history, and learnings
   - Check for directives in `.cursor/rules/*.mdc` files or directives folder
   - Understand existing patterns and architecture

2. **Generate Detailed Implementation Plan:**
   - Create a step-by-step implementation plan with:
     * **Objectives**: Clear goals and expected outcomes
     * **Proposed Changes**: Specific files and modifications
     * **Logic/Edge Cases**: All scenarios to handle
     * **FE/BE Separation**: Clear frontend/backend boundaries
     * **Dependencies**: Required libraries, services, or data
   - **EXPLICITLY WAIT FOR HUMAN CONFIRMATION** before proceeding to Phase 2

3. **Self-Annealing Check:**
   - Review any error logs, constraints, or learnings from previous executions
   - Update understanding based on past failures or edge cases

### PHASE 2: CONSTRUCT (ONLY AFTER APPROVED BLUEPRINT)
**Adhere STRICTLY to the approved plan:**

1. **Implementation Strategy:**
   - Implement changes in SMALL, GRANULAR chunks
   - Use "Rewrite this entire component" instead of "Change this" to trigger full regeneration
   - Avoid patchy edits that cause context pollution
   - Maintain code integrity throughout

2. **Code Generation Rules:**
   - Follow all coding standards (see Code Quality section below)
   - Maintain consistent structure and patterns
   - Ensure type safety across frontend/backend boundaries

### PHASE 3: EXECUTION (DETERMINISTIC ONLY)
**Execute ONLY deterministic scripts and MCP servers:**

1. **Execution Layer:**
   - Use deterministic Python scripts or MCP servers called by the plan
   - DO NOT attempt probabilistic execution for:
     * API calls
     * Data processing
     * Database interactions
   - All execution must be reliable and repeatable

2. **Error Handling & Self-Annealing:**
   - If an error occurs (Execution failure, rate limit, bug):
     1. Read the error message and stack trace carefully
     2. Fix and test the failing Execution script
     3. Update the original Directive (SOP) with learned constraints or edge cases
     4. Document the fix in workflow_state.md

# ============================================
# II. DOCUMENT MANAGEMENT AND CONTEXT CONTROL
# ============================================

## REQUIRED DOCUMENTATION STRUCTURE

### 1. The Constitution (Stable Context)
**File: `project_config.md` or `project_milestones.md`** (at project root)
- Project goals and vision
- Required technical stack
- Main objectives and key features
- Business context
- Long-term milestones
- **This is stable, long-term information**

### 2. The Dynamic Brain (Current State)
**File: `workflow_state.md` or `Documentation.md`**
- Current phase and active tasks
- Task history and progress
- Newly created schemas and file paths
- Continuous learnings and constraints
- Recent errors and their resolutions
- **This tracks current, dynamic state**

### 3. Context Isolation Rules
- **ALWAYS start a NEW chat session** for:
  * Unrelated subprojects
  * Major topic changes
  * Different feature areas
- **Never mix contexts** - this prevents history pollution and context forgetfulness
- Each session should have clear boundaries

### 4. Version Control Requirements
- **Commit work frequently** using Git to establish robust checkpoints
- The AI can be aggressive - frequent commits prevent:
  * Loss of work
  * Unnecessary dependencies being added
  * Folder structure mismanagement
- Create meaningful commit messages describing changes

# ============================================
# III. CODE QUALITY AND STANDARDS ENFORCEMENT
# ============================================

## A. CODE STYLE AND IDIOMACY

### Language-Specific Conventions
- **TypeScript/JavaScript:**
  * Use modern TypeScript conventions (avoid old React patterns)
  * Prefer functional components and hooks
  * Use async/await over promises
  * Strict type checking - NO `any` types unless absolutely necessary
  * Use const over let, never use var

### Naming Conventions
- **File names**: Use kebab-case (e.g., `user-profile.tsx`, `api-client.ts`)
- **Components**: PascalCase (e.g., `UserProfile`, `ApiClient`)
- **Functions/Variables**: camelCase (e.g., `getUserData`, `userId`)
- **Constants**: UPPER_SNAKE_CASE (e.g., `API_BASE_URL`)
- **Be consistent** with existing codebase patterns

### Prohibited Practices
- **DO NOT** add third-party tools/libraries without approval
- **DO NOT** use deprecated patterns or libraries
- **DO NOT** create unnecessary abstractions
- **DO NOT** violate existing architectural patterns

## B. STRUCTURE (FRONTEND/BACKEND SEPARATION)

### Frontend Structure
- Components MUST be in `components/` folder (outside Next.js app directory if applicable)
- Follow clear component hierarchy
- Separate concerns: UI components, business logic, data fetching
- Maintain clear component boundaries

### Backend Structure
- **Route endpoints**: Clear RESTful or GraphQL structure
- **Resource services**: Business logic layer
- **Resource actions**: Specific operation handlers
- Maintain clear separation between routes, services, and data access

### Full-Stack Consistency
- Ensure frontend and backend structures are consistent
- Document API contracts clearly
- Maintain clear boundaries between layers

## C. TYPE SAFETY (CRITICAL)

### Shared Schema Requirements
- **MANDATORY**: Use shared schema/package (e.g., Zod models or Pydantic)
- Synchronize interfaces between backend and frontend
- **NEVER** create duplicate type definitions
- Use a single source of truth for data contracts
- Ensure runtime validation matches compile-time types

### Type Enforcement
- All API contracts must be typed
- Frontend components must use typed props
- Backend endpoints must validate against shared schemas
- Database models must align with shared schemas

## D. UI/UX AESTHETICS

### Visual Standards (MANDATORY)
- Follow UI/UX Guidelines within project rules:
  * **Color palettes**: Use defined brand colors only
  * **Typography**: Use specified fonts (e.g., Inter font) with correct weights
  * **Responsiveness**: Mobile-first, ensure all breakpoints work
  * **Visual composition**: Follow spacing, alignment, and layout guidelines
  * **Accessibility**: WCAG compliance, proper ARIA labels, keyboard navigation

### Quality Standards
- Output MUST be aesthetically beautiful and marketable
- No placeholder designs - everything must be polished
- Consistent visual language across all components
- Professional appearance is non-negotiable

## E. MANDATORY QUALITY ASSURANCE

### Testing Requirements
- **MANDATORY**: Generate automated unit tests for new features
- Use appropriate frameworks:
  * **Python**: Pytest
  * **JavaScript/TypeScript**: Jest or Vitest
  * **React**: React Testing Library
- Test coverage should be meaningful and practical
- Test edge cases and error scenarios

### Code Quality Checks
- All code MUST pass linting (ESLint, Pylint, etc.)
- All code MUST be formatted (Prettier, Black, etc.)
- **Fix all auto-fixable issues automatically**
- No console.log statements in production code (use proper logging)
- No commented-out code (remove or explain why kept)

### Re-indexing Requirements
- Frequently re-index the codebase to prevent AI from:
  * Referencing deleted files
  * Using non-existent functions
  * Following outdated patterns
- Update context when significant refactoring occurs

# ============================================
# IV. ORCHESTRATION AND LLM UTILIZATION
# ============================================

## A. LLM MODEL SELECTION STRATEGY

### Primary LLM (Orchestration/Reasoning)
- **For Blueprint Phase**: Use high-reasoning models (GPT-4o, Claude Sonnet/Opus)
- **For Validation**: Use high-reasoning models for complex validation
- **For Simple Implementation**: Lower cost/high speed models (GPT-4o-mini) for deterministic steps
- **Rationale**: Blueprint and Validation need deep reasoning; simple implementation needs speed

### Advanced Reasoning for Complex Problems
- **MANDATORY for**: Refactoring, systematic bug hunting, architecture decisions
- Use sequential-thinking Model Context Protocol (MCP) server
- Transforms "black box" into transparent, auditable multi-step process
- Enables step-by-step reasoning verification

## B. AGENT FRAMEWORK INTEGRATION

### CrewAI for Subprojects (MANDATORY)
- **Use CrewAI** for building complex, collaborative subprojects within Execution Layer
- Provides deterministic execution with specialized agents:
  * Planner agent
  * Researcher agent
  * Executor agents
- All agents work toward structured, auditable goals

### CrewAI Configuration Requirements
- **Process Control**: MUST set process type to `Process.sequential` for maximum reliability
- **Structured Output**: MANDATORY use of Pydantic models or JSON schemas
  * Use Pydantic AI framework for enforcement
  * Ensures clean, consistent data handoffs to downstream systems
- **Agent Specialization**: Each agent should have clear, focused role

## C. ENTERPRISE INTEGRATION (OUTER LOOP)

### n8n as Enterprise Bus (MANDATORY)
- **n8n is REQUIRED** for Outer Loop orchestration
- Handles:
  * Scheduling and task management
  * Persistence and state management
  * Comprehensive error handling
  * External connectivity (CRM, databases, APIs)
- **CrewAI Execution**: Embed CrewAI agent execution as single, controllable step in n8n

### MCP Servers via n8n
- Build custom MCP servers in n8n
- Expose deterministic capabilities:
  * Database access
  * Utility scripts
  * External API integrations
- Bypass one-off API integrations in favor of reusable MCP servers

### No-Code Alternative (Optional/Supplemental)
- GenFuse AI can be used for non-technical teams
- **ONLY** for simpler, end-to-end automation workflows
- **MUST NOT** replace core CrewAI/n8n architecture for complex code-based services

# ============================================
# V. HOSTING AND DEPLOYMENT STRATEGY
# ============================================

## DEPLOYMENT ARCHITECTURE (SELF-HOSTED PREFERRED)

### Core Systems Hosting
- **n8n and CrewAI**: Self-hosted (On-Premise or Private VPC)
  * Maximum data privacy
  * Control over security protocols
  * Eliminates vendor lock-in for mission-critical IP

### Development Environment
- **Cursor IDE**: Local workstation
  * Used for iterative "vibe coding" guided by DOE framework
  * Rapid prototyping with AI assistance

### Deployment Target
- **Production**: Cloud-Native Architecture (Kubernetes/Cloud Run)
  * CrewAI/AutoGen compatible with cloud-native
  * Leverage Kubernetes for scaling and deployment efficiency
  * Maintains flexibility while ensuring scalability

# ============================================
# VI. EXECUTION WORKFLOW SUMMARY
# ============================================

## MANDATORY WORKFLOW STEPS

1. **READ FIRST**: Check for `project_config.md` and `workflow_state.md`
2. **READ SECOND**: Review all `.cursor/rules/*.mdc` files and directives folder
3. **PHASE 1 - BLUEPRINT**: Research, plan, and WAIT for approval
4. **PHASE 2 - CONSTRUCT**: Implement strictly according to approved plan
5. **PHASE 3 - EXECUTION**: Use deterministic scripts/MCP servers only
6. **SELF-ANNEALING**: Update documentation and rules with learnings
7. **COMMIT**: Frequent Git commits to maintain checkpoints
8. **CONTEXT ISOLATION**: Start new chat for unrelated topics

## CRITICAL REMINDERS

- **NO CODE without approved Blueprint**
- **NO probabilistic execution** - only deterministic
- **NO context mixing** - new chats for new topics
- **NO skipping documentation** - maintain project_config.md and workflow_state.md
- **NO untyped code** - use shared schemas
- **NO untested features** - unit tests are mandatory
- **NO aesthetic compromises** - output must be beautiful and marketable

# ============================================
# VII. CODE GENERATION BEST PRACTICES
# ============================================

## Code Organization
- Organize imports: external packages first, then internal imports
- Group related functionality together
- Clean up unused imports automatically
- Follow existing project structure strictly

## Error Handling
- Always include proper error handling
- Use try/catch blocks appropriately
- Never skip null checks or validation
- Log errors properly (no console.log in production)
- Implement defensive programming techniques

## Code Explanation
- Use descriptive variable names that explain intent
- Break down complicated operations into smaller steps
- Add comments explaining "why" not just "what"
- Document complex logic and algorithms
- Explain trade-offs in code comments when relevant

## Git Practices
- Before modifying existing code, explain what it currently does
- If making breaking changes, explain the impact
- Write clear, descriptive commit messages
- Commit frequently to maintain checkpoints
- Use conventional commit format when possible

# ============================================
# VIII. NETLIFY DEPLOYMENT & OPTIMIZATION
# ============================================

## NETLIFY DEPLOYMENT REQUIREMENTS (MANDATORY)

### Pre-Deployment Checklist
- [ ] All environment variables configured in Netlify dashboard
- [ ] Build command tested locally and succeeds
- [ ] Publish directory correctly configured
- [ ] Build plugins installed and configured (if needed)
- [ ] Headers and redirects configured (netlify.toml)
- [ ] Form handling configured (if applicable)
- [ ] Functions deployed and tested (if applicable)

### Netlify Configuration (netlify.toml)
**MANDATORY** - Every project must have proper netlify.toml:
```toml
[build]
  command = "npm run build"
  publish = ".next"

[build.environment]
  NODE_VERSION = "18"

[[headers]]
  for = "/*"
  [headers.values]
    X-Frame-Options = "DENY"
    X-XSS-Protection = "1; mode=block"
    X-Content-Type-Options = "nosniff"
    Referrer-Policy = "strict-origin-when-cross-origin"
    Permissions-Policy = "geolocation=(), microphone=(), camera=()"

[[redirects]]
  from = "/*"
  to = "/index.html"
  status = 200
```

### Build Optimization for Netlify
- **Static Generation**: Use Next.js static generation where possible
- **Image Optimization**: Use Next.js Image component with Netlify Image CDN
- **Edge Functions**: Use Netlify Edge Functions for serverless needs
- **Cache Strategy**: Configure proper cache headers
- **Build Time**: Optimize dependencies to reduce build time

### Deployment Accuracy Verification
- **Post-Deployment Checks**:
  * Verify all pages load correctly
  * Check all integrations are working
  * Test all forms and interactive elements
  * Verify API endpoints (if applicable)
  * Check environment variables are accessible
  * Verify analytics and tracking are active

# ============================================
# IX. SEO & SERP OPTIMIZATION (MANDATORY)
# ============================================

## TECHNICAL SEO REQUIREMENTS

### Meta Tags (MANDATORY for every page)
- **Title Tag**: 50-60 characters, include primary keyword, unique per page
- **Meta Description**: 150-160 characters, compelling, include keyword
- **Open Graph Tags**: og:title, og:description, og:image, og:url, og:type
- **Twitter Card Tags**: twitter:card, twitter:title, twitter:description, twitter:image
- **Canonical URL**: Prevent duplicate content issues
- **Robots Meta**: Control indexing behavior appropriately

### Structured Data (Schema.org JSON-LD)
**MANDATORY** - All pages should have appropriate structured data:
- Organization schema (homepage)
- Article schema (blog posts)
- Product schema (if applicable)
- BreadcrumbList schema (navigation)
- FAQ schema (if applicable)
- Review/Rating schema (if applicable)

### Technical SEO Implementation
- **XML Sitemap**: Auto-generated and submitted to Google Search Console
- **Robots.txt**: Properly configured to allow/disallow appropriately
- **URL Structure**: Clean, descriptive URLs with keywords
- **HTTPS**: All pages must use HTTPS (Netlify handles this)
- **Mobile-First**: Responsive design, mobile-friendly test must pass
- **Site Speed**: Pagespeed must meet targets (see Performance section)

### Keyword Research & Implementation
- **Primary Keywords**: Research and identify 3-5 primary keywords per page
- **Long-Tail Keywords**: Include relevant long-tail variations
- **Keyword Placement**:
  * H1 tag (one per page, include primary keyword)
  * First 100 words of content
  * URL slug
  * Image alt text
  * Internal links anchor text
- **Keyword Density**: Natural integration, avoid keyword stuffing

### Content SEO
- **Semantic HTML**: Proper use of H1-H6 hierarchy
- **Internal Linking**: Strategic internal links with descriptive anchor text
- **External Links**: Link to authoritative sources when relevant
- **Image Optimization**:
  * Descriptive alt text with keywords
  * Proper file names (descriptive, use hyphens)
  * Appropriate image sizes
- **Content Quality**: Unique, valuable, comprehensive content

### SERP Considerations
- **Featured Snippets**: Structure content to answer questions clearly
- **Rich Snippets**: Use structured data to enable rich results
- **Local SEO**: Include location data if applicable
- **E-A-T Signals**: Demonstrate Expertise, Authoritativeness, Trustworthiness
- **User Experience Signals**: Low bounce rate, high engagement, fast load times

# ============================================
# X. PAGESPEED & PERFORMANCE OPTIMIZATION
# ============================================

## PERFORMANCE TARGETS (MANDATORY)

### Core Web Vitals (Lighthouse)
- **LCP (Largest Contentful Paint)**: < 2.5 seconds
- **FID (First Input Delay)**: < 100 milliseconds
- **CLS (Cumulative Layout Shift)**: < 0.1
- **FCP (First Contentful Paint)**: < 1.8 seconds
- **TTI (Time to Interactive)**: < 3.8 seconds
- **TBT (Total Blocking Time)**: < 200 milliseconds
- **Speed Index**: < 3.4 seconds

### Lighthouse Scores (MANDATORY)
- **Performance**: ≥ 90
- **Accessibility**: ≥ 90
- **Best Practices**: ≥ 90
- **SEO**: ≥ 90

### Performance Optimization Strategies

#### Code Optimization
- **Tree Shaking**: Remove unused code
- **Code Splitting**: Split code by route/feature
- **Lazy Loading**: Load components and images on demand
- **Bundle Size**: Keep JavaScript bundles < 200KB (gzipped)
- **Minification**: Minify CSS, JavaScript, HTML
- **Compression**: Gzip/Brotli compression enabled

#### Image Optimization
- **Format**: Use WebP with fallbacks (JPEG/PNG)
- **Responsive Images**: Use srcset and sizes attributes
- **Lazy Loading**: Native lazy loading or intersection observer
- **Compression**: Optimize images (use tools like Squoosh, ImageOptim)
- **CDN**: Serve images from CDN (Netlify Image CDN)

#### Font Optimization
- **Font Display**: Use `font-display: swap` or `optional`
- **Font Subsetting**: Load only needed characters
- **Preload**: Preload critical fonts
- **System Fonts**: Consider system font stack for performance

#### Caching Strategy
- **Static Assets**: Long-term caching (1 year)
- **HTML**: Short-term caching or no cache
- **API Responses**: Appropriate cache headers
- **Service Worker**: Implement for offline capability (if applicable)

#### Third-Party Scripts
- **Defer/Async**: Load non-critical scripts asynchronously
- **Minimize**: Reduce number of third-party scripts
- **Lazy Load**: Load analytics/tracking after page load
- **CDN**: Use CDN for libraries when possible

# ============================================
# XI. FILE & FOLDER STRUCTURE STANDARDS
# ============================================

## MANDATORY STRUCTURE ORGANIZATION

### Frontend Structure (Next.js/React)
```
project-root/
├── app/                          # Next.js app directory
│   ├── (routes)/                # Route groups
│   ├── layout.tsx               # Root layout
│   ├── page.tsx                 # Homepage
│   ├── globals.css              # Global styles
│   └── metadata.ts              # SEO metadata config
├── components/                   # Components (OUTSIDE app/)
│   ├── ui/                      # Base UI components (Shadcn/ui)
│   ├── layout/                  # Layout components
│   ├── features/                # Feature-specific components
│   │   ├── [feature-name]/
│   │   │   ├── index.ts        # Barrel export
│   │   │   ├── [component].tsx
│   │   │   └── [component].test.tsx
│   └── shared/                  # Shared components
├── lib/                         # Utilities and helpers
│   ├── utils.ts
│   ├── constants.ts
│   └── validations.ts           # Zod schemas
├── hooks/                       # Custom React hooks
├── types/                       # TypeScript types
├── public/                      # Static assets
│   ├── images/
│   ├── icons/
│   └── fonts/
├── styles/                      # Additional styles
└── __tests__/                   # Integration tests
```

### Backend Structure (FastAPI/Express)
```
backend/
├── app/
│   ├── api/
│   │   └── v1/
│   │       └── routes/          # API route handlers
│   ├── core/
│   │   ├── config.py           # Configuration
│   │   └── security.py         # Auth/security
│   ├── services/               # Business logic
│   ├── models/                 # Data models (Pydantic/SQLAlchemy)
│   ├── schemas/                # Request/response schemas
│   └── utils/                  # Utilities
├── tests/                      # Backend tests
└── alembic/                    # Database migrations (if applicable)
```

### Shared Structure
```
shared/
├── schemas/                    # Zod/Pydantic shared schemas
│   ├── user.schema.ts
│   └── api.schema.ts
├── types/                      # Shared TypeScript types
└── constants/                  # Shared constants
```

### File Naming Conventions (MANDATORY)
- **Components**: PascalCase (UserProfile.tsx)
- **Utilities/Hooks**: camelCase (useAuth.ts, formatDate.ts)
- **Pages/Routes**: lowercase with hyphens (user-profile/page.tsx)
- **Tests**: [name].test.tsx or [name].spec.tsx
- **Types**: [name].types.ts
- **Constants**: UPPER_SNAKE_CASE for constants, camelCase for files

### Organization Rules
- **One component per file** (except barrel exports)
- **Co-locate** related files (component + test + types)
- **Barrel exports** (index.ts) for cleaner imports
- **Separate concerns**: UI, business logic, data fetching
- **Feature folders** for larger features
- **Shared folder** for truly reusable code

# ============================================
# XII. INTEGRATION ACCURACY & RELIABILITY
# ============================================

## INTEGRATION REQUIREMENTS (MANDATORY)

### Integration Best Practices
- **API Documentation**: Review API docs thoroughly before integration
- **Authentication**: Implement secure authentication (API keys, OAuth, etc.)
- **Error Handling**: Comprehensive error handling for all API calls
- **Rate Limiting**: Respect API rate limits, implement retry logic
- **Timeout Handling**: Set appropriate timeouts for all requests
- **Data Validation**: Validate all data at integration boundaries
- **Type Safety**: Use TypeScript types for all API contracts

### Integration Testing
- **Unit Tests**: Test integration logic in isolation
- **Integration Tests**: Test full integration flows
- **Mock Services**: Use mocks for external services in tests
- **Staging Environment**: Test integrations in staging before production
- **Error Scenarios**: Test error cases (network failures, API errors, etc.)

### Common Integration Patterns
- **API Client**: Create reusable API client with error handling
- **Service Layer**: Wrap integrations in service layer
- **Retry Logic**: Implement exponential backoff for retries
- **Circuit Breaker**: Consider circuit breaker pattern for critical integrations
- **Caching**: Cache API responses when appropriate
- **Webhooks**: Handle webhooks securely with verification

### Integration Checklist
- [ ] API authentication implemented correctly
- [ ] Error handling covers all failure scenarios
- [ ] Rate limiting respected
- [ ] Timeout handling implemented
- [ ] Data validation at boundaries
- [ ] Type definitions for API contracts
- [ ] Integration tests written
- [ ] Staging environment tested
- [ ] Error logging and monitoring
- [ ] Documentation updated

# ============================================
# XIII. FRAMEWORK & ARCHITECTURE SELECTION
# ============================================

## CORRECT TECHNOLOGY SELECTION (MANDATORY)

### Frontend Framework Selection
- **Next.js**: Required for SSR/SSG, SEO, optimal performance
  * Use App Router (not Pages Router) for new projects
  * Leverage static generation where possible
  * Use Server Components by default
- **React**: When Next.js isn't applicable, use React with Vite
- **TypeScript**: MANDATORY for all frontend code (no JavaScript)

### Backend Framework Selection
- **FastAPI** (Python): Preferred for APIs, high performance, async support
- **Express.js** (Node.js): When Node.js ecosystem alignment needed
- **TypeScript**: MANDATORY for Node.js backends

### Styling Framework & Dependencies
- **Tailwind CSS**: Primary styling framework (utility-first)
- **Shadcn/ui**: Component library (copy-paste, customizable)
- **Radix UI**: Headless components for complex UI (used by Shadcn)
- **Framer Motion**: Animation library for smooth, professional animations
- **Lucide React**: Icon library (modern, consistent)
- **Class Variance Authority (CVA)**: For component variants
- **Tailwind Merge**: Merge Tailwind classes without conflicts
- **clsx**: Conditional className utility

### State Management
- **React Context + useState/useReducer**: For simple state
- **Zustand**: For complex global state (lightweight)
- **TanStack Query (React Query)**: For server state (caching, sync)
- **Avoid Redux**: Unless absolutely necessary for complex apps

### Form Handling
- **React Hook Form**: Form state management
- **Zod**: Schema validation (shared with backend)
- **@hookform/resolvers**: Connect React Hook Form with Zod

### Database & ORM
- **PostgreSQL**: Preferred relational database
- **Prisma**: ORM for TypeScript/Node.js
- **SQLAlchemy**: ORM for Python/FastAPI
- **MongoDB**: Only when document database is appropriate

### Build Tools
- **Vite**: Fast build tool (when not using Next.js)
- **Turbopack**: Next.js's new bundler (use when stable)
- **ESBuild**: Fast bundler/transpiler

### Architecture Patterns
- **Layered Architecture**: Clear separation (routes → services → data)
- **Feature-Based**: Organize by features, not by file type
- **API-First**: Design APIs before implementation
- **Microservices**: When scale requires it (not prematurely)

# ============================================
# XIV. PEAK PERFORMANCE STANDARDS
# ============================================

## PERFORMANCE REQUIREMENTS (MANDATORY)

### Runtime Performance
- **JavaScript Execution**: Minimize main thread blocking
- **Memory Usage**: Monitor and optimize memory leaks
- **Re-renders**: Minimize unnecessary React re-renders (use React.memo, useMemo, useCallback)
- **Bundle Size**:
  * Initial bundle < 200KB (gzipped)
  * Total bundle < 500KB (gzipped)
  * Code split by route/feature

### Database Performance
- **Query Optimization**: Optimize database queries (avoid N+1)
- **Indexing**: Proper database indexes on frequently queried fields
- **Connection Pooling**: Use connection pooling for database connections
- **Caching**: Cache frequently accessed data (Redis, in-memory)

### API Performance
- **Response Times**: API endpoints < 200ms (p95)
- **Pagination**: Implement pagination for list endpoints
- **Filtering**: Allow filtering to reduce data transfer
- **Compression**: Enable gzip/brotli compression
- **Caching**: Cache API responses when appropriate

### Monitoring & Optimization
- **Performance Monitoring**: Use tools (Sentry, LogRocket, etc.)
- **Real User Monitoring (RUM)**: Track actual user performance
- **Regular Audits**: Run Lighthouse audits regularly
- **Performance Budgets**: Set and enforce performance budgets

# ============================================
# XV. STYLE & DESIGN EXCELLENCE
# ============================================

## DESIGN SYSTEM REQUIREMENTS (MANDATORY)

### Brand Identity & Aesthetics
**Style Personality**: Modern, Editorial, On-Brand, Raw, Edgy, Professional, Stylish

### Typography
- **Primary Font**: Inter (variable weight, modern, professional)
- **Secondary Font**: [Brand-specific font if applicable]
- **Font Weights**: Use 400 (regular), 500 (medium), 600 (semibold), 700 (bold)
- **Font Sizes**: Use consistent scale (text-xs through text-6xl)
- **Line Height**: 1.5-1.7 for body text, tighter for headings
- **Letter Spacing**: Slightly negative for headings, normal for body

### Color System
- **Primary Colors**: Brand-specific primary palette
- **Neutral Colors**: Gray scale (50-900) for text, backgrounds
- **Semantic Colors**: Success, error, warning, info
- **Dark Mode**: Full dark mode support with proper contrast
- **Accessibility**: WCAG AA contrast ratios (4.5:1 for text, 3:1 for UI)

### Spacing & Layout
- **Spacing Scale**: 4px base unit (4, 8, 12, 16, 20, 24, 32, 48, 64, 96, 128)
- **Container Max Width**: Consistent max-widths (1280px for desktop)
- **Grid System**: Use CSS Grid or Flexbox (no Bootstrap grid)
- **Responsive Breakpoints**: sm (640px), md (768px), lg (1024px), xl (1280px), 2xl (1536px)

### Component Design
- **Shadcn/ui Components**: Base component library (customizable, accessible)
- **Custom Components**: Build on Shadcn foundation, maintain consistency
- **Component Variants**: Use CVA for component variants (size, variant, state)
- **Accessibility**: ARIA labels, keyboard navigation, focus management

### Animation & Motion
- **Framer Motion**: Primary animation library
- **Animation Principles**:
  * Subtle and purposeful
  * 200-300ms for micro-interactions
  * Easing: ease-out for entrances, ease-in for exits
  * Respect prefers-reduced-motion
- **Transitions**: Smooth transitions for state changes
- **Loading States**: Skeleton loaders, progressive loading

### Visual Design Principles
- **Whitespace**: Generous whitespace for breathing room
- **Visual Hierarchy**: Clear hierarchy through size, weight, color
- **Consistency**: Consistent spacing, sizing, colors throughout
- **Edge Cases**: Design for empty states, error states, loading states
- **Polish**: No placeholders, everything must be production-ready

### Style Dependencies (Required)
```json
{
  "dependencies": {
    "tailwindcss": "^3.4.0",
    "@radix-ui/react-*": "latest",
    "framer-motion": "^11.0.0",
    "lucide-react": "^0.400.0",
    "class-variance-authority": "^0.7.0",
    "tailwind-merge": "^2.2.0",
    "clsx": "^2.1.0"
  }
}
```

### Design Checklist
- [ ] Typography system implemented
- [ ] Color system with dark mode
- [ ] Spacing scale consistent
- [ ] Component library (Shadcn/ui) set up
- [ ] Animations smooth and purposeful
- [ ] Responsive design tested on all breakpoints
- [ ] Accessibility (WCAG AA) verified
- [ ] Visual hierarchy clear
- [ ] Empty/error/loading states designed
- [ ] No placeholder content

# ============================================
# XVI. AUTOMATION RELIABILITY & VALIDATION
# ============================================

## AUTOMATION REQUIREMENTS (MANDATORY)

### Automation Design Principles
- **Deterministic**: All automations must be deterministic (same input = same output)
- **Idempotent**: Running multiple times should produce same result
- **Error Handling**: Comprehensive error handling and recovery
- **Logging**: Detailed logging for debugging and monitoring
- **Validation**: Validate inputs and outputs at every step
- **Testing**: Test automations thoroughly before deployment

### Pre-Deployment Validation
- **Unit Tests**: Test individual automation components
- **Integration Tests**: Test full automation workflows
- **Edge Case Testing**: Test error scenarios, rate limits, timeouts
- **Staging Environment**: Test in staging before production
- **Rollback Plan**: Have rollback procedure documented

### Runtime Monitoring
- **Error Tracking**: Monitor for errors (Sentry, custom logging)
- **Performance Monitoring**: Track execution time and resource usage
- **Alerting**: Set up alerts for failures or anomalies
- **Health Checks**: Implement health check endpoints
- **Metrics**: Track key metrics (success rate, execution time, etc.)

### Client-Facing Automation Checks
- **Accuracy**: Verify automations perform correctly
- **Reliability**: Ensure consistent performance
- **Data Integrity**: Verify data accuracy and consistency
- **User Experience**: Ensure smooth user experience
- **Error Recovery**: Graceful error handling visible to users

### Automation Testing Checklist
- [ ] All code paths tested
- [ ] Error scenarios handled
- [ ] Rate limits respected
- [ ] Timeout handling implemented
- [ ] Data validation at boundaries
- [ ] Logging comprehensive
- [ ] Monitoring configured
- [ ] Alerting set up
- [ ] Rollback procedure documented
- [ ] Staging environment tested

# ============================================
# END OF GLOBAL FOUNDATIONAL RULES
# ============================================

**These rules are MANDATORY and apply to ALL code generation, regardless of:**
- Project type
- Workspace location
- Chat session
- Model being used
- Task complexity
- Time constraints

**NO EXCEPTIONS. NO SHORTCUTS. QUALITY FIRST, ALWAYS.**
