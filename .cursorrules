
# üö® HARD STOP ‚Äî MCP ENFORCEMENT üö®

**MANDATORY FIRST ACTION IN EVERY CONVERSATION:**

Before responding to ANY request, you MUST:

1. **FIRST TOOL CALL**: Read `systems/mcp-server/DOE-ENFORCEMENT-CHECKLIST.md`
2. **SECOND TOOL CALL**: Call `systems/mcp-server/enforce-directive-check.js` with task description
3. **If status === "BLOCKED"**, you MUST:
   - Search `systems/doe-engine/directives/` using `list_dir` or `glob_file_search`
   - Explicitly report results: "‚úÖ DIRECTIVE FOUND: [filename]" OR "‚úÖ NO DIRECTIVE FOUND"
   - If no directive: Determine if one should be created (recurring? complex? consistency matters?)
   - Wait for user confirmation
4. **You may NOT proceed** until status is cleared
5. **VIOLATION**: If you skip steps 1-2, you are in violation. Stop immediately and correct.

**ENFORCEMENT**: The first two tool calls in EVERY conversation MUST be:
1. `read_file` ‚Üí `systems/mcp-server/DOE-ENFORCEMENT-CHECKLIST.md`
2. `run_terminal_cmd` ‚Üí `node systems/mcp-server/enforce-directive-check.js [task_description]`

**NO EXCEPTIONS. NO SHORTCUTS.**


# üö´ STOP - DO NOT PROCEED UNTIL YOU COMPLETE THE CHECKPOINT BELOW üö´

# ============================================

# MANDATORY PRE-FLIGHT CHECK - READ THIS FIRST

# ============================================

## ‚ö†Ô∏è CRITICAL: YOU MUST COMPLETE THIS CHECKPOINT BEFORE ANY OTHER ACTION ‚ö†Ô∏è

**BEFORE reading any code, making any changes, or taking any action, you MUST:**

1. **Acknowledge Reading**: Explicitly state: "I have read and understood the .cursorrules file"
2. **Confirm Understanding**: State the three mandatory phases (Directive ‚Üí Orchestration ‚Üí Execution)
3. **Verify Directive/Blueprint Requirement**: Confirm you will NOT write code without checking for directive or creating approved blueprint
4. **State Current Phase**: Declare which phase you are starting in (Check Directive ‚Üí Orchestrate ‚Üí Execute)
5. **Answer Verification Question**: What is the FIRST thing you must do before writing any code?

**REQUIRED RESPONSE FORMAT (Copy and fill out exactly):**

```
‚úÖ RULES ACKNOWLEDGMENT:
RULES_ACKNOWLEDGED: YES
DIRECTIVE_METHOD_UNDERSTOOD: YES
CODE_WITHOUT_DIRECTIVE_OR_BLUEPRINT: FORBIDDEN
CURRENT_PHASE: Check Directive ‚Üí Orchestrate ‚Üí Execute

VERIFICATION ANSWER: [Answer must include: "Check for directive, if coding work needed create blueprint in orchestration phase and wait for approval"]

I understand the three mandatory phases:
1. Directive ‚Üí Check for existing directive in systems/doe-engine/directives/
2. Orchestration ‚Üí If coding needed: create blueprint and WAIT for approval; If deterministic: use scripts/MCPs; Handle errors and self-anneal
3. Execution ‚Üí Implement according to approved blueprint or execute deterministic scripts/MCPs

I will NOT write code without checking for directive or creating approved blueprint.
I am starting in Phase 1: Check Directive (then Orchestrate, then Execute).

‚ö†Ô∏è MANDATORY CHECKPOINT: This file is a checkpoint. You cannot proceed without acknowledging the directive-first method above.
```

**IF YOU DO NOT PROVIDE THIS ACKNOWLEDGMENT IN THE EXACT FORMAT ABOVE, YOU ARE IN VIOLATION OF THE DIRECTIVE.**

**ONLY AFTER providing this acknowledgment may you proceed to read the rest of the rules and begin work.**

‚ö†Ô∏è REMINDER: If you haven't completed the pre-flight check above, STOP and go back to complete it now.

# ============================================

# GLOBAL FOUNDATIONAL RULES - DOE ARCHITECTURE

# This file applies to ALL projects, workspaces, windows, chats, and models

# MANDATORY ENFORCEMENT - NO EXCEPTIONS

# ============================================

# ============================================

# I. FOUNDATIONAL STRATEGY: DIRECTIVE-FIRST APPROACH

# ============================================

## THE DIRECTIVE-FIRST METHOD (MANDATORY)

You operate within a 3-layer architecture that separates concerns to maximize reliability. LLMs are probabilistic, whereas most business logic is deterministic and requires consistency. This system fixes that mismatch.

**Layer 1: Directive (What to do)**
- SOPs written in Markdown, live in `systems/doe-engine/directives/`
- Define goals, inputs, tools/scripts to use, outputs, and edge cases
- Natural language instructions, like you'd give a mid-level employee
- **All directives are centralized** - task-based, not folder-based

**Layer 2: Orchestration (Decision making)**
- This is you. Your job: intelligent routing.
- Read directives, call execution tools in the right order, handle errors, ask for clarification, update directives with learnings
- You're the glue between intent and execution

**Layer 3: Execution (Doing the work)**
- Deterministic Python scripts (or Shell/Node tools) in `systems/doe-engine/execution/`
- Handle API calls, data processing, file operations, database interactions
- Reliable, testable, fast. Use scripts instead of manual work.

**Why this works:** If you do everything yourself, errors compound. 90% accuracy per step = 59% success over 5 steps. The solution is push complexity into deterministic code. That way you just focus on decision-making.

**Reference:** See `systems/doe-engine/gemini.md` for complete architecture details.

### PHASE 1: CHECK DIRECTIVE (MANDATORY FIRST STEP)

‚ö†Ô∏è REMINDER: If you haven't completed the pre-flight check at the top of this file, STOP and go back.

**üö´ HARD-STOP ENFORCEMENT: BEFORE ANY WORK, YOU MUST EXPLICITLY REPORT DIRECTIVE SEARCH RESULTS üö´**

**BEFORE taking ANY action (reading code, making changes, writing files, running commands), you MUST:**

1. **FIRST: Search Directives Directory:**
   - **MANDATORY FIRST ACTION**: Search `systems/doe-engine/directives/` for relevant directives
   - Use `list_dir` or `glob_file_search` to examine the directives folder
   - Search for directive files matching the task (e.g., `systems/doe-engine/directives/{task-name}.md`)

2. **REPORT SEARCH RESULTS (EXPLICIT STATEMENT REQUIRED):**
   - **YOU MUST EXPLICITLY STATE ONE OF THE FOLLOWING:**
     * `"‚úÖ DIRECTIVE SEARCH RESULT: Found directive: systems/doe-engine/directives/[name].md"` (with exact filename)
     * `"‚úÖ DIRECTIVE SEARCH RESULT: Found multiple directives: [list all names]"`
     * `"‚úÖ DIRECTIVE SEARCH RESULT: No directive found for this task"`
   - **YOU CANNOT PROCEED** until you have explicitly stated this result
   - **NO EXCEPTIONS** - this is a hard-stop checkpoint

3. **After Reporting Search Results:**
   - **If directive exists:** Read it fully before proceeding
   - **If no directive exists:** Use 3-question test to determine if one should be created:
     * Will I do this again? (Recurring)
     * Is this complex? (Multiple steps, integrations)
     * Does consistency matter? (Same quality every time)
   - **If 2+ answers are "Yes" ‚Üí Ask user if directive should be created**
   - **If 0-1 answers are "Yes" ‚Üí Skip directive, proceed to orchestration**

4. **Check for Execution Scripts/MCPs:**
   - Before writing code, check: `systems/doe-engine/execution/`
   - Check: `automations/mcps/` for reusable MCPs
   - Check: `systems/mcp-server/automations/` for alternative location
   - If script/MCP exists: Use it (don't rewrite)
   - If no script exists: Create one for deterministic operations

**VIOLATION OF THIS RULE:** If you proceed with any work without explicitly reporting the directive search result, you are in violation of the directive-first method.

### PHASE 2: ORCHESTRATION (DECISION MAKING)

‚ö†Ô∏è REMINDER: If you haven't completed the pre-flight check at the top of this file, STOP and go back.

**Your role: intelligent routing and decision-making**

1. **If Directive Exists:**
   - Read directive fully to understand goals, inputs, outputs, edge cases
   - Follow directive's process steps
   - Use execution scripts/MCPs referenced in directive
   - **For coding/development work within directive:**
     * Create detailed blueprint with:
       - Objectives: Clear goals and expected outcomes
       - Proposed Changes: Specific files and modifications
       - Logic/Edge Cases: All scenarios to handle
       - FE/BE Separation: Clear frontend/backend boundaries
       - Dependencies: Required libraries, services, or data
     * **EXPLICITLY WAIT FOR HUMAN CONFIRMATION** before proceeding to execution
   - **For deterministic work:**
     * Use existing execution scripts/MCPs
     * Call scripts in correct order as specified in directive
   - Handle errors and self-anneal (see Self-Annealing section below)

2. **If No Directive Exists (Simple/One-off Tasks):**
   - **For coding work:** Create blueprint ‚Üí Get approval ‚Üí Execute
   - **For deterministic work:** Use existing scripts or create new ones
   - **For exploratory work:** Proceed but note what directive could be created

3. **Self-Annealing (MANDATORY):**
   - **When errors occur:**
     1. Read error message and stack trace carefully
     2. Fix the execution script/MCP and test it again (unless it uses paid tokens/credits‚Äîcheck with user first)
     3. Update the directive with what you learned (API limits, timing, edge cases, better approaches)
     4. Document the fix in `workflow_state.md` or directive's "Learnings" section
   - **When you discover improvements:**
     * Update directive with new constraints, better approaches, common errors, timing expectations
     * Directives are living documents - improve them over time
     * **Ask permission before updating directives** (unless explicitly told not to)
   - **Learning from Variations:**
     * First time: Adapt process manually, document what you did
     * Update directive: Add variation to edge cases section, document adaptation process
     * Next time: Follow updated directive, process is now reliable
     * Create new directive only if: Process is fundamentally different (not just parameters)
   - **Self-Annealing Loop:**
     * Errors are learning opportunities
     * Fix it ‚Üí Update the tool ‚Üí Test tool ‚Üí Update directive ‚Üí System is now stronger

### PHASE 3: EXECUTION (DETERMINISTIC ONLY)

**Execute ONLY deterministic scripts and MCP servers:**

1. **Execution Layer:**
   - Use deterministic Python scripts or MCP servers called by directive or blueprint
   - DO NOT attempt probabilistic execution for:
     - API calls
     - Data processing
     - Database interactions
   - All execution must be reliable and repeatable

2. **Error Handling & Self-Annealing:**
   - If an error occurs (Execution failure, rate limit, bug):
     1. Read the error message and stack trace carefully
     2. Fix and test the failing Execution script/MCP
     3. Update the original Directive with learned constraints or edge cases
     4. Document the fix in `workflow_state.md` or directive's "Learnings" section
     5. System is now stronger - same error won't happen again

# ============================================

# II. DOCUMENT MANAGEMENT AND CONTEXT CONTROL

# ============================================

## REQUIRED DOCUMENTATION STRUCTURE

### 1. The Constitution (Stable Context)

**File: `project_config.md` or `project_milestones.md`** (at project root)

- Project goals and vision
- Required technical stack
- Main objectives and key features
- Business context
- Long-term milestones
- **This is stable, long-term information**

### 2. The Dynamic Brain (Current State)

**File: `workflow_state.md` or `Documentation.md`**

- Current phase and active tasks
- Task history and progress
- Newly created schemas and file paths
- Continuous learnings and constraints
- Recent errors and their resolutions
- **This tracks current, dynamic state**

### 3. Context Isolation Rules

- **ALWAYS start a NEW chat session** for:
  - Unrelated subprojects
  - Major topic changes
  - Different feature areas
- **Never mix contexts** - this prevents history pollution and context forgetfulness
- Each session should have clear boundaries

### 4. Version Control Requirements

- **Commit work frequently** using Git to establish robust checkpoints
- The AI can be aggressive - frequent commits prevent:
  - Loss of work
  - Unnecessary dependencies being added
  - Folder structure mismanagement
- Create meaningful commit messages describing changes

# ============================================

# III. CODE QUALITY AND STANDARDS ENFORCEMENT

# ============================================

## A. CODE STYLE AND IDIOMACY

### Language-Specific Conventions

- **TypeScript/JavaScript:**
  - Use modern TypeScript conventions (avoid old React patterns)
  - Prefer functional components and hooks
  - Use async/await over promises
  - Strict type checking - NO `any` types unless absolutely necessary
  - Use const over let, never use var

### Naming Conventions

- **File names**: Use kebab-case (e.g., `user-profile.tsx`, `api-client.ts`)
- **Components**: PascalCase (e.g., `UserProfile`, `ApiClient`)
- **Functions/Variables**: camelCase (e.g., `getUserData`, `userId`)
- **Constants**: UPPER_SNAKE_CASE (e.g., `API_BASE_URL`)
- **Be consistent** with existing codebase patterns

### Prohibited Practices

- **DO NOT** add third-party tools/libraries without approval
- **DO NOT** use deprecated patterns or libraries
- **DO NOT** create unnecessary abstractions
- **DO NOT** violate existing architectural patterns

## B. STRUCTURE (FRONTEND/BACKEND SEPARATION)

### Frontend Structure

- Components MUST be in `components/` folder (outside Next.js app directory if applicable)
- Follow clear component hierarchy
- Separate concerns: UI components, business logic, data fetching
- Maintain clear component boundaries

### Backend Structure

- **Route endpoints**: Clear RESTful or GraphQL structure
- **Resource services**: Business logic layer
- **Resource actions**: Specific operation handlers
- Maintain clear separation between routes, services, and data access

### Full-Stack Consistency

- Ensure frontend and backend structures are consistent
- Document API contracts clearly
- Maintain clear boundaries between layers

## C. TYPE SAFETY (CRITICAL)

### Shared Schema Requirements

- **MANDATORY**: Use shared schema/package (e.g., Zod models or Pydantic)
- Synchronize interfaces between backend and frontend
- **NEVER** create duplicate type definitions
- Use a single source of truth for data contracts
- Ensure runtime validation matches compile-time types

### Type Enforcement

- All API contracts must be typed
- Frontend components must use typed props
- Backend endpoints must validate against shared schemas
- Database models must align with shared schemas

## D. UI/UX AESTHETICS

### Visual Standards (MANDATORY)

- Follow UI/UX Guidelines within project rules:
  - **Color palettes**: Use defined brand colors only
  - **Typography**: Use specified fonts (e.g., Inter font) with correct weights
  - **Responsiveness**: Mobile-first, ensure all breakpoints work
  - **Visual composition**: Follow spacing, alignment, and layout guidelines
  - **Accessibility**: WCAG compliance, proper ARIA labels, keyboard navigation

### Quality Standards

- Output MUST be aesthetically beautiful and marketable
- No placeholder designs - everything must be polished
- Consistent visual language across all components
- Professional appearance is non-negotiable

## E. MANDATORY QUALITY ASSURANCE

### Testing Requirements

- **MANDATORY**: Generate automated unit tests for new features
- Use appropriate frameworks:
  - **Python**: Pytest
  - **JavaScript/TypeScript**: Jest or Vitest
  - **React**: React Testing Library
- Test coverage should be meaningful and practical
- Test edge cases and error scenarios

### Code Quality Checks

- All code MUST pass linting (ESLint, Pylint, etc.)
- All code MUST be formatted (Prettier, Black, etc.)
- **Fix all auto-fixable issues automatically**
- No console.log statements in production code (use proper logging)
- No commented-out code (remove or explain why kept)

### Re-indexing Requirements

- Frequently re-index the codebase to prevent AI from:
  - Referencing deleted files
  - Using non-existent functions
  - Following outdated patterns
- Update context when significant refactoring occurs

# ============================================

# IV. ORCHESTRATION AND LLM UTILIZATION

# ============================================

## A. LLM MODEL SELECTION STRATEGY

### Primary LLM (Orchestration/Reasoning)

- **For Directive/Blueprint Phase**: Use high-reasoning models (GPT-4o, Claude Sonnet/Opus)
- **For Validation**: Use high-reasoning models for complex validation
- **For Simple Implementation**: Lower cost/high speed models (GPT-4o-mini) for deterministic steps
- **Rationale**: Directive reading, blueprint creation, and validation need deep reasoning; simple implementation needs speed

### Advanced Reasoning for Complex Problems

- **MANDATORY for**: Refactoring, systematic bug hunting, architecture decisions
- Use sequential-thinking Model Context Protocol (MCP) server
- Transforms "black box" into transparent, auditable multi-step process
- Enables step-by-step reasoning verification

## B. AGENT FRAMEWORK INTEGRATION

### CrewAI for Subprojects (MANDATORY)

- **Use CrewAI** for building complex, collaborative subprojects within Execution Layer
- Provides deterministic execution with specialized agents:
  - Planner agent
  - Researcher agent
  - Executor agents
- All agents work toward structured, auditable goals

### CrewAI Configuration Requirements

- **Process Control**: MUST set process type to `Process.sequential` for maximum reliability
- **Structured Output**: MANDATORY use of Pydantic models or JSON schemas
  - Use Pydantic AI framework for enforcement
  - Ensures clean, consistent data handoffs to downstream systems
- **Agent Specialization**: Each agent should have clear, focused role

## C. ENTERPRISE INTEGRATION (OUTER LOOP)

### n8n as Enterprise Bus (MANDATORY)

- **n8n is REQUIRED** for Outer Loop orchestration
- Handles:
  - Scheduling and task management
  - Persistence and state management
  - Comprehensive error handling
  - External connectivity (CRM, databases, APIs)
- **CrewAI Execution**: Embed CrewAI agent execution as single, controllable step in n8n

### MCP Servers via n8n

- Build custom MCP servers in n8n
- Expose deterministic capabilities:
  - Database access
  - Utility scripts
  - External API integrations
- Bypass one-off API integrations in favor of reusable MCP servers

### No-Code Alternative (Optional/Supplemental)

- GenFuse AI can be used for non-technical teams
- **ONLY** for simpler, end-to-end automation workflows
- **MUST NOT** replace core CrewAI/n8n architecture for complex code-based services

# ============================================

# V. HOSTING AND DEPLOYMENT STRATEGY

# ============================================

## DEPLOYMENT ARCHITECTURE (SELF-HOSTED PREFERRED)

### Core Systems Hosting

- **n8n and CrewAI**: Self-hosted (On-Premise or Private VPC)
  - Maximum data privacy
  - Control over security protocols
  - Eliminates vendor lock-in for mission-critical IP

### Development Environment

- **Cursor IDE**: Local workstation
  - Used for iterative "vibe coding" guided by DOE framework
  - Rapid prototyping with AI assistance

### Deployment Target

- **Production**: Cloud-Native Architecture (Kubernetes/Cloud Run)
  - CrewAI/AutoGen compatible with cloud-native
  - Leverage Kubernetes for scaling and deployment efficiency
  - Maintains flexibility while ensuring scalability

# ============================================

# VI. EXECUTION WORKFLOW SUMMARY

# ============================================

## MANDATORY WORKFLOW STEPS

1. **READ FIRST**: Check for `project_config.md` and `workflow_state.md`
2. **READ SECOND**: Review all `.cursor/rules/*.mdc` files and directives in `systems/doe-engine/directives/`
3. **PHASE 1 - CHECK DIRECTIVE**: Check for existing directive in `systems/doe-engine/directives/`
4. **PHASE 2 - ORCHESTRATE**: 
   - If directive exists: Follow it, create blueprint if coding work needed, get approval
   - If no directive: Use 3-question test, create blueprint if coding, or use scripts if deterministic
   - Handle errors and self-anneal (update directive with learnings)
5. **PHASE 3 - EXECUTE**: Use deterministic scripts/MCP servers only
6. **SELF-ANNEALING**: Update directive with learnings, update execution scripts, document in workflow_state.md
7. **COMMIT**: Frequent Git commits to maintain checkpoints
8. **CONTEXT ISOLATION**: Start new chat for unrelated topics

## CRITICAL REMINDERS

‚ö†Ô∏è REMINDER: If you haven't completed the pre-flight check at the top of this file, STOP and go back.

- **NO CODE without checking directive or creating approved blueprint**
- **NO probabilistic execution** - only deterministic scripts/MCPs
- **NO context mixing** - new chats for new topics
- **NO skipping documentation** - maintain project_config.md and workflow_state.md
- **NO untyped code** - use shared schemas
- **NO untested features** - unit tests are mandatory
- **NO aesthetic compromises** - output must be beautiful and marketable
- **NO skipping the pre-flight check** - acknowledgment is mandatory before any action
- **NO skipping self-annealing** - always update directive with learnings when errors occur or improvements are discovered

# ============================================

# VII. CODE GENERATION BEST PRACTICES

# ============================================

## Code Organization

- Organize imports: external packages first, then internal imports
- Group related functionality together
- Clean up unused imports automatically
- Follow existing project structure strictly

## Error Handling

- Always include proper error handling
- Use try/catch blocks appropriately
- Never skip null checks or validation
- Log errors properly (no console.log in production)
- Implement defensive programming techniques

## Code Explanation

- Use descriptive variable names that explain intent
- Break down complicated operations into smaller steps
- Add comments explaining "why" not just "what"
- Document complex logic and algorithms
- Explain trade-offs in code comments when relevant

## Git Practices

- Before modifying existing code, explain what it currently does
- If making breaking changes, explain the impact
- Write clear, descriptive commit messages
- Commit frequently to maintain checkpoints
- Use conventional commit format when possible

### User Control Over Git Operations (MANDATORY)

- **NEVER run git commit or git push automatically**
- **ALWAYS prepare changes and inform the user what needs to be committed**
- **WAIT for user to explicitly request commit/push operations**
- The user controls when commits and pushes happen
- Provide the exact commands the user should run, but don't run them

# ============================================

# VIII. NETLIFY DEPLOYMENT & OPTIMIZATION

# ============================================

## NETLIFY DEPLOYMENT REQUIREMENTS (MANDATORY)

### Pre-Deployment Checklist

- [ ] All environment variables configured in Netlify dashboard
- [ ] Build command tested locally and succeeds
- [ ] Publish directory correctly configured
- [ ] Build plugins installed and configured (if needed)
- [ ] Headers and redirects configured (netlify.toml)
- [ ] Form handling configured (if applicable)
- [ ] Functions deployed and tested (if applicable)

### Netlify Configuration (netlify.toml)

**MANDATORY** - Every project must have proper netlify.toml:

```toml
[build]
  command = "npm run build"
  publish = ".next"

[build.environment]
  NODE_VERSION = "18"

[[headers]]
  for = "/*"
  [headers.values]
    X-Frame-Options = "DENY"
    X-XSS-Protection = "1; mode=block"
    X-Content-Type-Options = "nosniff"
    Referrer-Policy = "strict-origin-when-cross-origin"
    Permissions-Policy = "geolocation=(), microphone=(), camera=()"

[[redirects]]
  from = "/*"
  to = "/index.html"
  status = 200
```

### Build Optimization for Netlify

- **Static Generation**: Use Next.js static generation where possible
- **Image Optimization**: Use Next.js Image component with Netlify Image CDN
- **Edge Functions**: Use Netlify Edge Functions for serverless needs
- **Cache Strategy**: Configure proper cache headers
- **Build Time**: Optimize dependencies to reduce build time

### Deployment Accuracy Verification

- **Post-Deployment Checks**:
  - Verify all pages load correctly
  - Check all integrations are working
  - Test all forms and interactive elements
  - Verify API endpoints (if applicable)
  - Check environment variables are accessible
  - Verify analytics and tracking are active

# ============================================

# IX. SEO & SERP OPTIMIZATION (MANDATORY)

# ============================================

## TECHNICAL SEO REQUIREMENTS

### Meta Tags (MANDATORY for every page)

- **Title Tag**: 50-60 characters, include primary keyword, unique per page
- **Meta Description**: 150-160 characters, compelling, include keyword
- **Open Graph Tags**: og:title, og:description, og:image, og:url, og:type
- **Twitter Card Tags**: twitter:card, twitter:title, twitter:description, twitter:image
- **Canonical URL**: Prevent duplicate content issues
- **Robots Meta**: Control indexing behavior appropriately

### Structured Data (Schema.org JSON-LD)

**MANDATORY** - All pages should have appropriate structured data:

- Organization schema (homepage)
- Article schema (blog posts)
- Product schema (if applicable)
- BreadcrumbList schema (navigation)
- FAQ schema (if applicable)
- Review/Rating schema (if applicable)

### Technical SEO Implementation

- **XML Sitemap**: Auto-generated and submitted to Google Search Console
- **Robots.txt**: Properly configured to allow/disallow appropriately
- **URL Structure**: Clean, descriptive URLs with keywords
- **HTTPS**: All pages must use HTTPS (Netlify handles this)
- **Mobile-First**: Responsive design, mobile-friendly test must pass
- **Site Speed**: Pagespeed must meet targets (see Performance section)

### Keyword Research & Implementation

- **Primary Keywords**: Research and identify 3-5 primary keywords per page
- **Long-Tail Keywords**: Include relevant long-tail variations
- **Keyword Placement**:
  - H1 tag (one per page, include primary keyword)
  - First 100 words of content
  - URL slug
  - Image alt text
  - Internal links anchor text
- **Keyword Density**: Natural integration, avoid keyword stuffing

### Content SEO

- **Semantic HTML**: Proper use of H1-H6 hierarchy
- **Internal Linking**: Strategic internal links with descriptive anchor text
- **External Links**: Link to authoritative sources when relevant
- **Image Optimization**:
  - Descriptive alt text with keywords
  - Proper file names (descriptive, use hyphens)
  - Appropriate image sizes
- **Content Quality**: Unique, valuable, comprehensive content

### SERP Considerations

- **Featured Snippets**: Structure content to answer questions clearly
- **Rich Snippets**: Use structured data to enable rich results
- **Local SEO**: Include location data if applicable
- **E-A-T Signals**: Demonstrate Expertise, Authoritativeness, Trustworthiness
- **User Experience Signals**: Low bounce rate, high engagement, fast load times

# ============================================

# X. PAGESPEED & PERFORMANCE OPTIMIZATION

# ============================================

## PERFORMANCE TARGETS (MANDATORY)

### Core Web Vitals (Lighthouse)

- **LCP (Largest Contentful Paint)**: < 2.5 seconds
- **FID (First Input Delay)**: < 100 milliseconds
- **CLS (Cumulative Layout Shift)**: < 0.1
- **FCP (First Contentful Paint)**: < 1.8 seconds
- **TTI (Time to Interactive)**: < 3.8 seconds
- **TBT (Total Blocking Time)**: < 200 milliseconds
- **Speed Index**: < 3.4 seconds

### Lighthouse Scores (MANDATORY)

- **Performance**: ‚â• 90
- **Accessibility**: ‚â• 90
- **Best Practices**: ‚â• 90
- **SEO**: ‚â• 90

### Performance Optimization Strategies

#### Code Optimization

- **Tree Shaking**: Remove unused code
- **Code Splitting**: Split code by route/feature
- **Lazy Loading**: Load components and images on demand
- **Bundle Size**: Keep JavaScript bundles < 200KB (gzipped)
- **Minification**: Minify CSS, JavaScript, HTML
- **Compression**: Gzip/Brotli compression enabled

#### Image Optimization

- **Format**: Use WebP with fallbacks (JPEG/PNG)
- **Responsive Images**: Use srcset and sizes attributes
- **Lazy Loading**: Native lazy loading or intersection observer
- **Compression**: Optimize images (use tools like Squoosh, ImageOptim)
- **CDN**: Serve images from CDN (Netlify Image CDN)

#### Font Optimization

- **Font Display**: Use `font-display: swap` or `optional`
- **Font Subsetting**: Load only needed characters
- **Preload**: Preload critical fonts
- **System Fonts**: Consider system font stack for performance

#### Caching Strategy

- **Static Assets**: Long-term caching (1 year)
- **HTML**: Short-term caching or no cache
- **API Responses**: Appropriate cache headers
- **Service Worker**: Implement for offline capability (if applicable)

#### Third-Party Scripts

- **Defer/Async**: Load non-critical scripts asynchronously
- **Minimize**: Reduce number of third-party scripts
- **Lazy Load**: Load analytics/tracking after page load
- **CDN**: Use CDN for libraries when possible

# ============================================

# XI. FILE & FOLDER STRUCTURE STANDARDS

# ============================================

## MANDATORY STRUCTURE ORGANIZATION

### Frontend Structure (Next.js/React)

```
project-root/
‚îú‚îÄ‚îÄ app/                          # Next.js app directory
‚îÇ   ‚îú‚îÄ‚îÄ (routes)/                # Route groups
‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx               # Root layout
‚îÇ   ‚îú‚îÄ‚îÄ page.tsx                 # Homepage
‚îÇ   ‚îú‚îÄ‚îÄ globals.css              # Global styles
‚îÇ   ‚îî‚îÄ‚îÄ metadata.ts              # SEO metadata config
‚îú‚îÄ‚îÄ components/                   # Components (OUTSIDE app/)
‚îÇ   ‚îú‚îÄ‚îÄ ui/                      # Base UI components (Shadcn/ui)
‚îÇ   ‚îú‚îÄ‚îÄ layout/                  # Layout components
‚îÇ   ‚îú‚îÄ‚îÄ features/                # Feature-specific components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ [feature-name]/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.ts        # Barrel export
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ [component].tsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ [component].test.tsx
‚îÇ   ‚îî‚îÄ‚îÄ shared/                  # Shared components
‚îú‚îÄ‚îÄ lib/                         # Utilities and helpers
‚îÇ   ‚îú‚îÄ‚îÄ utils.ts
‚îÇ   ‚îú‚îÄ‚îÄ constants.ts
‚îÇ   ‚îî‚îÄ‚îÄ validations.ts           # Zod schemas
‚îú‚îÄ‚îÄ hooks/                       # Custom React hooks
‚îú‚îÄ‚îÄ types/                       # TypeScript types
‚îú‚îÄ‚îÄ public/                      # Static assets
‚îÇ   ‚îú‚îÄ‚îÄ images/
‚îÇ   ‚îú‚îÄ‚îÄ icons/
‚îÇ   ‚îî‚îÄ‚îÄ fonts/
‚îú‚îÄ‚îÄ styles/                      # Additional styles
‚îî‚îÄ‚îÄ __tests__/                   # Integration tests
```

### Backend Structure (FastAPI/Express)

```
backend/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ v1/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ routes/          # API route handlers
‚îÇ   ‚îú‚îÄ‚îÄ core/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config.py           # Configuration
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ security.py         # Auth/security
‚îÇ   ‚îú‚îÄ‚îÄ services/               # Business logic
‚îÇ   ‚îú‚îÄ‚îÄ models/                 # Data models (Pydantic/SQLAlchemy)
‚îÇ   ‚îú‚îÄ‚îÄ schemas/                # Request/response schemas
‚îÇ   ‚îî‚îÄ‚îÄ utils/                  # Utilities
‚îú‚îÄ‚îÄ tests/                      # Backend tests
‚îî‚îÄ‚îÄ alembic/                    # Database migrations (if applicable)
```

### Shared Structure

```
shared/
‚îú‚îÄ‚îÄ schemas/                    # Zod/Pydantic shared schemas
‚îÇ   ‚îú‚îÄ‚îÄ user.schema.ts
‚îÇ   ‚îî‚îÄ‚îÄ api.schema.ts
‚îú‚îÄ‚îÄ types/                      # Shared TypeScript types
‚îî‚îÄ‚îÄ constants/                  # Shared constants
```

### File Naming Conventions (MANDATORY)

- **Components**: PascalCase (UserProfile.tsx)
- **Utilities/Hooks**: camelCase (useAuth.ts, formatDate.ts)
- **Pages/Routes**: lowercase with hyphens (user-profile/page.tsx)
- **Tests**: [name].test.tsx or [name].spec.tsx
- **Types**: [name].types.ts
- **Constants**: UPPER_SNAKE_CASE for constants, camelCase for files

### Organization Rules

- **One component per file** (except barrel exports)
- **Co-locate** related files (component + test + types)
- **Barrel exports** (index.ts) for cleaner imports
- **Separate concerns**: UI, business logic, data fetching
- **Feature folders** for larger features
- **Shared folder** for truly reusable code

# ============================================

# XII. INTEGRATION ACCURACY & RELIABILITY

# ============================================

## INTEGRATION REQUIREMENTS (MANDATORY)

### Integration Best Practices

- **API Documentation**: Review API docs thoroughly before integration
- **Authentication**: Implement secure authentication (API keys, OAuth, etc.)
- **Error Handling**: Comprehensive error handling for all API calls
- **Rate Limiting**: Respect API rate limits, implement retry logic
- **Timeout Handling**: Set appropriate timeouts for all requests
- **Data Validation**: Validate all data at integration boundaries
- **Type Safety**: Use TypeScript types for all API contracts

### Integration Testing

- **Unit Tests**: Test integration logic in isolation
- **Integration Tests**: Test full integration flows
- **Mock Services**: Use mocks for external services in tests
- **Staging Environment**: Test integrations in staging before production
- **Error Scenarios**: Test error cases (network failures, API errors, etc.)

### Common Integration Patterns

- **API Client**: Create reusable API client with error handling
- **Service Layer**: Wrap integrations in service layer
- **Retry Logic**: Implement exponential backoff for retries
- **Circuit Breaker**: Consider circuit breaker pattern for critical integrations
- **Caching**: Cache API responses when appropriate
- **Webhooks**: Handle webhooks securely with verification

### Integration Checklist

- [ ] API authentication implemented correctly
- [ ] Error handling covers all failure scenarios
- [ ] Rate limiting respected
- [ ] Timeout handling implemented
- [ ] Data validation at boundaries
- [ ] Type definitions for API contracts
- [ ] Integration tests written
- [ ] Staging environment tested
- [ ] Error logging and monitoring
- [ ] Documentation updated

# ============================================

# XIII. FRAMEWORK & ARCHITECTURE SELECTION

# ============================================

## CORRECT TECHNOLOGY SELECTION (MANDATORY)

### Frontend Framework Selection

- **Next.js**: Required for SSR/SSG, SEO, optimal performance
  - Use App Router (not Pages Router) for new projects
  - Leverage static generation where possible
  - Use Server Components by default
- **React**: When Next.js isn't applicable, use React with Vite
- **TypeScript**: MANDATORY for all frontend code (no JavaScript)

### Backend Framework Selection

- **FastAPI** (Python): Preferred for APIs, high performance, async support
- **Express.js** (Node.js): When Node.js ecosystem alignment needed
- **TypeScript**: MANDATORY for Node.js backends

### Styling Framework & Dependencies

- **Tailwind CSS**: Primary styling framework (utility-first)
- **Shadcn/ui**: Component library (copy-paste, customizable)
- **Radix UI**: Headless components for complex UI (used by Shadcn)
- **Framer Motion**: Animation library for smooth, professional animations
- **Lucide React**: Icon library (modern, consistent)
- **Class Variance Authority (CVA)**: For component variants
- **Tailwind Merge**: Merge Tailwind classes without conflicts
- **clsx**: Conditional className utility

### State Management

- **React Context + useState/useReducer**: For simple state
- **Zustand**: For complex global state (lightweight)
- **TanStack Query (React Query)**: For server state (caching, sync)
- **Avoid Redux**: Unless absolutely necessary for complex apps

### Form Handling

- **React Hook Form**: Form state management
- **Zod**: Schema validation (shared with backend)
- **@hookform/resolvers**: Connect React Hook Form with Zod

### Database & ORM

- **PostgreSQL**: Preferred relational database
- **Prisma**: ORM for TypeScript/Node.js
- **SQLAlchemy**: ORM for Python/FastAPI
- **MongoDB**: Only when document database is appropriate

### Build Tools

- **Vite**: Fast build tool (when not using Next.js)
- **Turbopack**: Next.js's new bundler (use when stable)
- **ESBuild**: Fast bundler/transpiler

### Architecture Patterns

- **Layered Architecture**: Clear separation (routes ‚Üí services ‚Üí data)
- **Feature-Based**: Organize by features, not by file type
- **API-First**: Design APIs before implementation
- **Microservices**: When scale requires it (not prematurely)

# ============================================

# XIV. PEAK PERFORMANCE STANDARDS

# ============================================

## PERFORMANCE REQUIREMENTS (MANDATORY)

### Runtime Performance

- **JavaScript Execution**: Minimize main thread blocking
- **Memory Usage**: Monitor and optimize memory leaks
- **Re-renders**: Minimize unnecessary React re-renders (use React.memo, useMemo, useCallback)
- **Bundle Size**:
  - Initial bundle < 200KB (gzipped)
  - Total bundle < 500KB (gzipped)
  - Code split by route/feature

### Database Performance

- **Query Optimization**: Optimize database queries (avoid N+1)
- **Indexing**: Proper database indexes on frequently queried fields
- **Connection Pooling**: Use connection pooling for database connections
- **Caching**: Cache frequently accessed data (Redis, in-memory)

### API Performance

- **Response Times**: API endpoints < 200ms (p95)
- **Pagination**: Implement pagination for list endpoints
- **Filtering**: Allow filtering to reduce data transfer
- **Compression**: Enable gzip/brotli compression
- **Caching**: Cache API responses when appropriate

### Monitoring & Optimization

- **Performance Monitoring**: Use tools (Sentry, LogRocket, etc.)
- **Real User Monitoring (RUM)**: Track actual user performance
- **Regular Audits**: Run Lighthouse audits regularly
- **Performance Budgets**: Set and enforce performance budgets

# ============================================

# XV. STYLE & DESIGN EXCELLENCE

# ============================================

## DESIGN SYSTEM REQUIREMENTS (MANDATORY)

### Brand Identity & Aesthetics

**Style Personality**: Modern, Editorial, On-Brand, Raw, Edgy, Professional, Stylish

### Typography

- **Primary Font**: Inter (variable weight, modern, professional)
- **Secondary Font**: [Brand-specific font if applicable]
- **Font Weights**: Use 400 (regular), 500 (medium), 600 (semibold), 700 (bold)
- **Font Sizes**: Use consistent scale (text-xs through text-6xl)
- **Line Height**: 1.5-1.7 for body text, tighter for headings
- **Letter Spacing**: Slightly negative for headings, normal for body

### Color System

- **Primary Colors**: Brand-specific primary palette
- **Neutral Colors**: Gray scale (50-900) for text, backgrounds
- **Semantic Colors**: Success, error, warning, info
- **Dark Mode**: Full dark mode support with proper contrast
- **Accessibility**: WCAG AA contrast ratios (4.5:1 for text, 3:1 for UI)

### Spacing & Layout

- **Spacing Scale**: 4px base unit (4, 8, 12, 16, 20, 24, 32, 48, 64, 96, 128)
- **Container Max Width**: Consistent max-widths (1280px for desktop)
- **Grid System**: Use CSS Grid or Flexbox (no Bootstrap grid)
- **Responsive Breakpoints**: sm (640px), md (768px), lg (1024px), xl (1280px), 2xl (1536px)

### Component Design

- **Shadcn/ui Components**: Base component library (customizable, accessible)
- **Custom Components**: Build on Shadcn foundation, maintain consistency
- **Component Variants**: Use CVA for component variants (size, variant, state)
- **Accessibility**: ARIA labels, keyboard navigation, focus management

### Animation & Motion

- **Framer Motion**: Primary animation library
- **Animation Principles**:
  - Subtle and purposeful
  - 200-300ms for micro-interactions
  - Easing: ease-out for entrances, ease-in for exits
  - Respect prefers-reduced-motion
- **Transitions**: Smooth transitions for state changes
- **Loading States**: Skeleton loaders, progressive loading

### Visual Design Principles

- **Whitespace**: Generous whitespace for breathing room
- **Visual Hierarchy**: Clear hierarchy through size, weight, color
- **Consistency**: Consistent spacing, sizing, colors throughout
- **Edge Cases**: Design for empty states, error states, loading states
- **Polish**: No placeholders, everything must be production-ready

### Style Dependencies (Required)

```json
{
  "dependencies": {
    "tailwindcss": "^3.4.0",
    "@radix-ui/react-*": "latest",
    "framer-motion": "^11.0.0",
    "lucide-react": "^0.400.0",
    "class-variance-authority": "^0.7.0",
    "tailwind-merge": "^2.2.0",
    "clsx": "^2.1.0"
  }
}
```

### Design Checklist

- [ ] Typography system implemented
- [ ] Color system with dark mode
- [ ] Spacing scale consistent
- [ ] Component library (Shadcn/ui) set up
- [ ] Animations smooth and purposeful
- [ ] Responsive design tested on all breakpoints
- [ ] Accessibility (WCAG AA) verified
- [ ] Visual hierarchy clear
- [ ] Empty/error/loading states designed
- [ ] No placeholder content

# ============================================

# XVI. AUTOMATION RELIABILITY & VALIDATION

# ============================================

## AUTOMATION REQUIREMENTS (MANDATORY)

### Automation Design Principles

- **Deterministic**: All automations must be deterministic (same input = same output)
- **Idempotent**: Running multiple times should produce same result
- **Error Handling**: Comprehensive error handling and recovery
- **Logging**: Detailed logging for debugging and monitoring
- **Validation**: Validate inputs and outputs at every step
- **Testing**: Test automations thoroughly before deployment

### Pre-Deployment Validation

- **Unit Tests**: Test individual automation components
- **Integration Tests**: Test full automation workflows
- **Edge Case Testing**: Test error scenarios, rate limits, timeouts
- **Staging Environment**: Test in staging before production
- **Rollback Plan**: Have rollback procedure documented

### Runtime Monitoring

- **Error Tracking**: Monitor for errors (Sentry, custom logging)
- **Performance Monitoring**: Track execution time and resource usage
- **Alerting**: Set up alerts for failures or anomalies
- **Health Checks**: Implement health check endpoints
- **Metrics**: Track key metrics (success rate, execution time, etc.)

### Client-Facing Automation Checks

- **Accuracy**: Verify automations perform correctly
- **Reliability**: Ensure consistent performance
- **Data Integrity**: Verify data accuracy and consistency
- **User Experience**: Ensure smooth user experience
- **Error Recovery**: Graceful error handling visible to users

### Automation Testing Checklist

- [ ] All code paths tested
- [ ] Error scenarios handled
- [ ] Rate limits respected
- [ ] Timeout handling implemented
- [ ] Data validation at boundaries
- [ ] Logging comprehensive
- [ ] Monitoring configured
- [ ] Alerting set up
- [ ] Rollback procedure documented
- [ ] Staging environment tested

# ============================================

# END OF GLOBAL FOUNDATIONAL RULES

# ============================================

**These rules are MANDATORY and apply to ALL code generation, regardless of:**

- Project type
- Workspace location
- Chat session
- Model being used
- Task complexity
- Time constraints

**NO EXCEPTIONS. NO SHORTCUTS. QUALITY FIRST, ALWAYS.**

# ============================================

# XVII. DOE DISPATCHER ENFORCEMENT

# ============================================

## MANDATORY: Use DOE Dispatcher for Directive-Based Tasks

**CRITICAL RULE**: All tasks that follow directives MUST use the DOE dispatcher system, NOT direct execution.

### Required Pattern for Directive-Based Tasks

**FORBIDDEN:**
- Directly calling execution-layer scripts with `python`/`python3` (no direct script execution)
- Bypassing the dispatcher and worker queue
- Skipping ACK token validation

**REQUIRED:**
- Use `node ./cursor/start-task.js <task_type> <project_id> <task_id> <actor_id> [payload_json]`
- All directive-based work must go through the dispatcher
- ACK tokens must be obtained and validated

### When to Use Each System

**Use Direct MCP Automations (`/run` endpoint):**
- Simple utilities (create-client-folder, extract-client-info)
- No directive required
- Immediate execution needed

**Use DOE Dispatcher (`cursor/start-task.js`):**
- Any task that follows a directive
- Tasks requiring ACK tokens
- Tasks needing queuing, retry, or self-annealing
- Python execution scripts

### Enforcement

If you need to execute a task that uses an execution-layer script:
1. Check if it follows a directive (look in `systems/doe-engine/directives/`)
2. If directive exists: MUST use `node ./cursor/start-task.js`
3. Never bypass the dispatcher for directive-based tasks

**This ensures:**
- All directive-based work is tracked
- ACK tokens are properly issued and validated
- Self-annealing can occur when needed
- Audit trail is maintained
